<teammate-message teammate_id="team-lead">
You are the backend-cache agent. Your task is to implement a Redis response cache layer for API endpoints and fix redirect_slashes.

## Task from TaskList: #1 — Backend: Redis response cache + redirect_slashes fix

## What to do

### 1. Create `backend/src/infrastructure/cache/response_cache.py`

Create a generic async Redis cache helper:

```python
"""Redis-backed response cache for API endpoints."""

import json
import logging
from collections.abc import Callable, Coroutine
from typing import Any

import redis.asyncio as redis

from src.infrastructure.cache.redis_client import get_redis_pool

logger = logging.getLogger(__name__)


class ResponseCache:
    """Simple Redis cache with TTL for API response caching."""

    _PREFIX = "cache:"

    def __init__(self) -> None:
        pool = get_redis_pool()
        self._redis = redis.Redis(connection_pool=pool)

    async def get_or_fetch(
        self,
        key: str,
        ttl: int,
        fetch_fn: Callable[[], Coroutine[Any, Any, Any]],
    ) -> Any:
        """Return cached value or call fetch_fn, cache result, and return it."""
        full_key = f"{self._PREFIX}{key}"
        try:
            cached = await self._redis.get(full_key)
            if cached is not None:
                return json.loads(cached)
        except Exception:
            logger.warning("Cache read failed for %s, falling through", full_key)

        result = await fetch_fn()

        try:
            await self._redis.setex(full_key, ttl, json.dumps(result, default=str))
        except Exception:
            logger.warning("Cache write failed for %s", full_key)

        return result


# Module-level singleton
response_cache = ResponseCache()
```

### 2. Add cache to monitoring routes (`backend/src/presentation/api/v1/monitoring/routes.py`)

Wrap the three endpoint bodies with response_cache.get_or_fetch:

For `health_check`:
```python
from src.infrastructure.cache.response_cache import response_cache

@router.get("/health", ...)
async def health_check(...):
    async def _fetch():
        # existing logic (db_check, redis_check, remnawave_check, use_case)
        ...
        return result
    
    result = await response_cache.get_or_fetch("monitoring:health", 10, _fetch)
    monitoring_operations_total.labels(operation="health_check").inc()
    return result
```

For `get_system_stats`: wrap with key `"monitoring:stats"`, TTL 15
For `get_bandwidth_analytics`: wrap with key `f"monitoring:bandwidth:{period}"`, TTL 10

### 3. Add cache to servers routes (`backend/src/presentation/api/v1/servers/routes.py`)

For `list_servers`: wrap with key `"servers:list"`, TTL 30
For `get_server_stats`: wrap with key `"servers:stats"`, TTL 15

Only cache the GET list and stats endpoints — not create/update/delete.

### 4. Add cache to usage routes (`backend/src/presentation/api/v1/usage/routes.py`)

For `get_usage`: wrap with key `f"usage:{current_user.id}"`, TTL 30

### 5. Add `redirect_slashes=False` to FastAPI app

In `backend/src/main.py`, add `redirect_slashes=False` to the FastAPI constructor (around line 234):
```python
app = FastAPI(
    title="CyberVPN Backend API",
    ...
    redirect_slashes=False,  # ADD THIS
)
```

## Important Rules
- Read each file before editing
- Keep existing code structure — wrap in cache, don't rewrite
- Use existing redis_client pool, don't create new connections
- Don't change function signatures of routes
- The cache should be transparent — same response format

## When Done
Mark task #1 as completed via TaskUpdate.
</teammate-message>